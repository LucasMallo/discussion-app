/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/naja/dist/Naja.esm.js":
/*!********************************************!*\
  !*** ./node_modules/naja/dist/Naja.esm.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HttpError\": () => (/* binding */ HttpError),\n/* harmony export */   \"Naja\": () => (/* binding */ Naja),\n/* harmony export */   \"default\": () => (/* binding */ naja)\n/* harmony export */ });\n/*\n * Naja.js\n * 2.5.0\n *\n * by Jiří Pudil <https://jiripudil.cz>\n */\n// ready\nconst onDomReady = callback => {\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', callback);\n  } else {\n    callback();\n  }\n};\n// assert\nclass AssertionError extends Error {}\nconst assert = (condition, description) => {\n  if (!condition) {\n    const message = `Assertion failed${description !== undefined ? `: ${description}` : '.'}`;\n    throw new AssertionError(message);\n  }\n};\nclass UIHandler extends EventTarget {\n  constructor(naja) {\n    super();\n    this.naja = naja;\n    this.selector = '.ajax';\n    this.allowedOrigins = [window.location.origin];\n    this.handler = this.handleUI.bind(this);\n    naja.addEventListener('init', this.initialize.bind(this));\n  }\n  initialize() {\n    onDomReady(() => this.bindUI(window.document.body));\n    this.naja.snippetHandler.addEventListener('afterUpdate', event => {\n      const {\n        snippet\n      } = event.detail;\n      this.bindUI(snippet);\n    });\n  }\n  bindUI(element) {\n    const selectors = [`a${this.selector}`, `input[type=\"submit\"]${this.selector}`, `input[type=\"image\"]${this.selector}`, `button[type=\"submit\"]${this.selector}`, `form${this.selector} input[type=\"submit\"]`, `form${this.selector} input[type=\"image\"]`, `form${this.selector} button[type=\"submit\"]`].join(', ');\n    const bindElement = element => {\n      element.removeEventListener('click', this.handler);\n      element.addEventListener('click', this.handler);\n    };\n    const elements = element.querySelectorAll(selectors);\n    for (let i = 0; i < elements.length; i++) {\n      bindElement(elements.item(i));\n    }\n    if (element.matches(selectors)) {\n      bindElement(element);\n    }\n    const bindForm = form => {\n      form.removeEventListener('submit', this.handler);\n      form.addEventListener('submit', this.handler);\n    };\n    if (element.matches(`form${this.selector}`)) {\n      bindForm(element);\n    }\n    const forms = element.querySelectorAll(`form${this.selector}`);\n    for (let i = 0; i < forms.length; i++) {\n      bindForm(forms.item(i));\n    }\n  }\n  handleUI(event) {\n    const mouseEvent = event;\n    if (mouseEvent.altKey || mouseEvent.ctrlKey || mouseEvent.shiftKey || mouseEvent.metaKey || mouseEvent.button) {\n      return;\n    }\n    const element = event.currentTarget;\n    const options = this.naja.prepareOptions();\n    const ignoreErrors = () => {\n      // don't reject the promise in case of an error as developers have no way of handling the rejection\n      // in this situation; errors should be handled in `naja.addEventListener('error', errorHandler)`\n    };\n    if (event.type === 'submit') {\n      this.submitForm(element, options, event).catch(ignoreErrors);\n    } else if (event.type === 'click') {\n      this.clickElement(element, options, mouseEvent).catch(ignoreErrors);\n    }\n  }\n  async clickElement(element, options = {}, event) {\n    let method = 'GET',\n      url = '',\n      data;\n    if (!this.dispatchEvent(new CustomEvent('interaction', {\n      cancelable: true,\n      detail: {\n        element,\n        originalEvent: event,\n        options\n      }\n    }))) {\n      event?.preventDefault();\n      return {};\n    }\n    if (element.tagName === 'A') {\n      assert(element instanceof HTMLAnchorElement);\n      method = 'GET';\n      url = element.href;\n      data = null;\n    } else if (element.tagName === 'INPUT' || element.tagName === 'BUTTON') {\n      assert(element instanceof HTMLInputElement || element instanceof HTMLButtonElement);\n      const {\n        form\n      } = element;\n      // eslint-disable-next-line no-nested-ternary,no-extra-parens\n      method = element.getAttribute('formmethod')?.toUpperCase() ?? form?.getAttribute('method')?.toUpperCase() ?? 'GET';\n      url = element.getAttribute('formaction') ?? form?.getAttribute('action') ?? window.location.pathname + window.location.search;\n      data = new FormData(form ?? undefined);\n      if (element.type === 'submit' && element.name !== '') {\n        data.append(element.name, element.value || '');\n      } else if (element.type === 'image') {\n        const coords = element.getBoundingClientRect();\n        const prefix = element.name !== '' ? `${element.name}.` : '';\n        data.append(`${prefix}x`, Math.max(0, Math.floor(event !== undefined ? event.pageX - coords.left : 0)));\n        data.append(`${prefix}y`, Math.max(0, Math.floor(event !== undefined ? event.pageY - coords.top : 0)));\n      }\n    }\n    if (!this.isUrlAllowed(url)) {\n      throw new Error(`Cannot dispatch async request, URL is not allowed: ${url}`);\n    }\n    event?.preventDefault();\n    return this.naja.makeRequest(method, url, data, options);\n  }\n  async submitForm(form, options = {}, event) {\n    if (!this.dispatchEvent(new CustomEvent('interaction', {\n      cancelable: true,\n      detail: {\n        element: form,\n        originalEvent: event,\n        options\n      }\n    }))) {\n      event?.preventDefault();\n      return {};\n    }\n    const method = form.getAttribute('method')?.toUpperCase() ?? 'GET';\n    const url = form.getAttribute('action') ?? window.location.pathname + window.location.search;\n    const data = new FormData(form);\n    if (!this.isUrlAllowed(url)) {\n      throw new Error(`Cannot dispatch async request, URL is not allowed: ${url}`);\n    }\n    event?.preventDefault();\n    return this.naja.makeRequest(method, url, data, options);\n  }\n  isUrlAllowed(url) {\n    const urlObject = new URL(url, location.href);\n    // ignore non-URL URIs (javascript:, data:, mailto:, ...)\n    if (urlObject.origin === 'null') {\n      return false;\n    }\n    return this.allowedOrigins.includes(urlObject.origin);\n  }\n}\nclass FormsHandler {\n  constructor(naja) {\n    this.naja = naja;\n    naja.addEventListener('init', this.initialize.bind(this));\n    naja.uiHandler.addEventListener('interaction', this.processForm.bind(this));\n  }\n  initialize() {\n    onDomReady(() => this.initForms(window.document.body));\n    this.naja.snippetHandler.addEventListener('afterUpdate', event => {\n      const {\n        snippet\n      } = event.detail;\n      this.initForms(snippet);\n    });\n  }\n  initForms(element) {\n    const netteForms = this.netteForms || window.Nette;\n    if (netteForms) {\n      if (element.tagName === 'form') {\n        netteForms.initForm(element);\n      }\n      const forms = element.querySelectorAll('form');\n      for (let i = 0; i < forms.length; i++) {\n        netteForms.initForm(forms.item(i));\n      }\n    }\n  }\n  processForm(event) {\n    const {\n      element,\n      originalEvent\n    } = event.detail;\n    const inputElement = element;\n    if (inputElement.form !== undefined && inputElement.form !== null) {\n      inputElement.form['nette-submittedBy'] = element;\n    }\n    const netteForms = this.netteForms || window.Nette;\n    if ((element.tagName === 'FORM' || element.form) && netteForms && !netteForms.validateForm(element)) {\n      if (originalEvent) {\n        originalEvent.stopImmediatePropagation();\n        originalEvent.preventDefault();\n      }\n      event.preventDefault();\n    }\n  }\n}\nclass RedirectHandler extends EventTarget {\n  constructor(naja) {\n    super();\n    this.naja = naja;\n    naja.uiHandler.addEventListener('interaction', event => {\n      const {\n        element,\n        options\n      } = event.detail;\n      if (!element) {\n        return;\n      }\n      if (element.hasAttribute('data-naja-force-redirect') || element.form?.hasAttribute('data-naja-force-redirect')) {\n        const value = element.getAttribute('data-naja-force-redirect') ?? element.form?.getAttribute('data-naja-force-redirect');\n        options.forceRedirect = value !== 'off';\n      }\n    });\n    naja.addEventListener('success', event => {\n      const {\n        payload,\n        options\n      } = event.detail;\n      if (payload.redirect) {\n        this.makeRedirect(payload.redirect, options.forceRedirect ?? false, options);\n        event.stopImmediatePropagation();\n      }\n    });\n    this.locationAdapter = {\n      assign: url => window.location.assign(url)\n    };\n  }\n  makeRedirect(url, force, options = {}) {\n    if (url instanceof URL) {\n      url = url.href;\n    }\n    let isHardRedirect = force || !this.naja.uiHandler.isUrlAllowed(url);\n    const canRedirect = this.dispatchEvent(new CustomEvent('redirect', {\n      cancelable: true,\n      detail: {\n        url,\n        isHardRedirect,\n        setHardRedirect(value) {\n          isHardRedirect = !!value;\n        },\n        options\n      }\n    }));\n    if (!canRedirect) {\n      return;\n    }\n    if (isHardRedirect) {\n      this.locationAdapter.assign(url);\n    } else {\n      this.naja.makeRequest('GET', url, null, options);\n    }\n  }\n}\nclass SnippetHandler extends EventTarget {\n  constructor(naja) {\n    super();\n    this.naja = naja;\n    this.op = {\n      replace: (snippet, content) => {\n        snippet.innerHTML = content;\n      },\n      prepend: (snippet, content) => snippet.insertAdjacentHTML('afterbegin', content),\n      append: (snippet, content) => snippet.insertAdjacentHTML('beforeend', content)\n    };\n    naja.addEventListener('success', event => {\n      const {\n        options,\n        payload\n      } = event.detail;\n      if (payload.snippets) {\n        this.updateSnippets(payload.snippets, false, options);\n      }\n    });\n  }\n  static findSnippets(predicate) {\n    const result = {};\n    const snippets = window.document.querySelectorAll('[id^=\"snippet-\"]');\n    for (let i = 0; i < snippets.length; i++) {\n      const snippet = snippets.item(i);\n      if (predicate?.(snippet) ?? true) {\n        result[snippet.id] = snippet.innerHTML;\n      }\n    }\n    return result;\n  }\n  updateSnippets(snippets, fromCache = false, options = {}) {\n    Object.keys(snippets).forEach(id => {\n      const snippet = document.getElementById(id);\n      if (snippet) {\n        this.updateSnippet(snippet, snippets[id], fromCache, options);\n      }\n    });\n  }\n  updateSnippet(snippet, content, fromCache, options) {\n    let operation = this.op.replace;\n    if ((snippet.hasAttribute('data-naja-snippet-prepend') || snippet.hasAttribute('data-ajax-prepend')) && !fromCache) {\n      operation = this.op.prepend;\n    } else if ((snippet.hasAttribute('data-naja-snippet-append') || snippet.hasAttribute('data-ajax-append')) && !fromCache) {\n      operation = this.op.append;\n    }\n    const canUpdate = this.dispatchEvent(new CustomEvent('beforeUpdate', {\n      cancelable: true,\n      detail: {\n        snippet,\n        content,\n        fromCache,\n        operation,\n        changeOperation(value) {\n          operation = value;\n        },\n        options\n      }\n    }));\n    if (!canUpdate) {\n      return;\n    }\n    if (snippet.tagName.toLowerCase() === 'title') {\n      document.title = content;\n    } else {\n      operation(snippet, content);\n    }\n    this.dispatchEvent(new CustomEvent('afterUpdate', {\n      cancelable: true,\n      detail: {\n        snippet,\n        content,\n        fromCache,\n        operation,\n        options\n      }\n    }));\n  }\n}\nclass HistoryHandler extends EventTarget {\n  constructor(naja) {\n    super();\n    this.naja = naja;\n    this.initialized = false;\n    this.popStateHandler = this.handlePopState.bind(this);\n    naja.addEventListener('init', this.initialize.bind(this));\n    naja.addEventListener('before', this.saveUrl.bind(this));\n    naja.addEventListener('before', this.replaceInitialState.bind(this));\n    naja.addEventListener('success', this.pushNewState.bind(this));\n    naja.uiHandler.addEventListener('interaction', this.configureMode.bind(this));\n    this.historyAdapter = {\n      replaceState: (state, title, url) => window.history.replaceState(state, title, url),\n      pushState: (state, title, url) => window.history.pushState(state, title, url)\n    };\n  }\n  set uiCache(value) {\n    console.warn('Naja: HistoryHandler.uiCache is deprecated, use options.snippetCache instead.');\n    this.naja.defaultOptions.snippetCache = value;\n  }\n  handlePopState(event) {\n    const {\n      state\n    } = event;\n    if (state?.source !== 'naja') {\n      return;\n    }\n    const options = this.naja.prepareOptions();\n    this.dispatchEvent(new CustomEvent('restoreState', {\n      detail: {\n        state,\n        options\n      }\n    }));\n  }\n  initialize() {\n    window.addEventListener('popstate', this.popStateHandler);\n  }\n  saveUrl(event) {\n    const {\n      url,\n      options\n    } = event.detail;\n    options.href ??= url;\n  }\n  replaceInitialState(event) {\n    const {\n      options\n    } = event.detail;\n    const mode = HistoryHandler.normalizeMode(options.history);\n    if (mode !== false && !this.initialized) {\n      onDomReady(() => this.historyAdapter.replaceState(this.buildState(window.location.href, options), window.document.title, window.location.href));\n      this.initialized = true;\n    }\n  }\n  configureMode(event) {\n    const {\n      element,\n      options\n    } = event.detail;\n    // propagate mode to options\n    if (!element) {\n      return;\n    }\n    if (element.hasAttribute('data-naja-history') || element.form?.hasAttribute('data-naja-history')) {\n      const value = element.getAttribute('data-naja-history') ?? element.form?.getAttribute('data-naja-history');\n      options.history = HistoryHandler.normalizeMode(value);\n    }\n  }\n  static normalizeMode(mode) {\n    if (mode === 'off' || mode === false) {\n      return false;\n    } else if (mode === 'replace') {\n      return 'replace';\n    }\n    return true;\n  }\n  pushNewState(event) {\n    const {\n      payload,\n      options\n    } = event.detail;\n    const mode = HistoryHandler.normalizeMode(options.history);\n    if (mode === false) {\n      return;\n    }\n    if (payload.postGet && payload.url) {\n      options.href = payload.url;\n    }\n    const method = mode === 'replace' ? 'replaceState' : 'pushState';\n    this.historyAdapter[method](this.buildState(options.href, options), window.document.title, options.href);\n  }\n  buildState(href, options) {\n    const state = {\n      source: 'naja',\n      href\n    };\n    this.dispatchEvent(new CustomEvent('buildState', {\n      detail: {\n        state,\n        options\n      }\n    }));\n    return state;\n  }\n}\nclass SnippetCache extends EventTarget {\n  constructor(naja) {\n    super();\n    this.naja = naja;\n    this.storages = {\n      off: new OffCacheStorage(naja),\n      history: new HistoryCacheStorage(),\n      session: new SessionCacheStorage()\n    };\n    naja.uiHandler.addEventListener('interaction', this.configureCache.bind(this));\n    naja.historyHandler.addEventListener('buildState', this.buildHistoryState.bind(this));\n    naja.historyHandler.addEventListener('restoreState', this.restoreHistoryState.bind(this));\n  }\n  resolveStorage(option) {\n    let storageType;\n    if (option === true || option === undefined) {\n      storageType = 'history';\n    } else if (option === false) {\n      storageType = 'off';\n    } else {\n      storageType = option;\n    }\n    return this.storages[storageType];\n  }\n  configureCache(event) {\n    const {\n      element,\n      options\n    } = event.detail;\n    if (!element) {\n      return;\n    }\n    if (element.hasAttribute('data-naja-snippet-cache') || element.form?.hasAttribute('data-naja-snippet-cache') || element.hasAttribute('data-naja-history-cache') || element.form?.hasAttribute('data-naja-history-cache')) {\n      const value = element.getAttribute('data-naja-snippet-cache') ?? element.form?.getAttribute('data-naja-snippet-cache') ?? element.getAttribute('data-naja-history-cache') ?? element.form?.getAttribute('data-naja-history-cache');\n      options.snippetCache = value;\n    }\n  }\n  buildHistoryState(event) {\n    const {\n      state,\n      options\n    } = event.detail;\n    if ('historyUiCache' in options) {\n      console.warn('Naja: options.historyUiCache is deprecated, use options.snippetCache instead.');\n      options.snippetCache = options.historyUiCache;\n    }\n    const snippets = SnippetHandler.findSnippets(snippet => !snippet.hasAttribute('data-naja-history-nocache') && !snippet.hasAttribute('data-history-nocache') && (!snippet.hasAttribute('data-naja-snippet-cache') || snippet.getAttribute('data-naja-snippet-cache') !== 'off'));\n    if (!this.dispatchEvent(new CustomEvent('store', {\n      cancelable: true,\n      detail: {\n        snippets,\n        state,\n        options\n      }\n    }))) {\n      return;\n    }\n    const storage = this.resolveStorage(options.snippetCache);\n    state.snippets = {\n      storage: storage.type,\n      key: storage.store(snippets)\n    };\n  }\n  restoreHistoryState(event) {\n    const {\n      state,\n      options\n    } = event.detail;\n    if (state.snippets === undefined) {\n      return;\n    }\n    options.snippetCache = state.snippets.storage;\n    if (!this.dispatchEvent(new CustomEvent('fetch', {\n      cancelable: true,\n      detail: {\n        state,\n        options\n      }\n    }))) {\n      return;\n    }\n    const storage = this.resolveStorage(options.snippetCache);\n    const snippets = storage.fetch(state.snippets.key, state, options);\n    if (snippets === null) {\n      return;\n    }\n    if (!this.dispatchEvent(new CustomEvent('restore', {\n      cancelable: true,\n      detail: {\n        snippets,\n        state,\n        options\n      }\n    }))) {\n      return;\n    }\n    this.naja.snippetHandler.updateSnippets(snippets, true, options);\n    this.naja.scriptLoader.loadScripts(snippets);\n  }\n}\nclass OffCacheStorage {\n  constructor(naja) {\n    this.naja = naja;\n    this.type = 'off';\n  } // eslint-disable-line no-empty-function\n  store() {\n    return null;\n  }\n  fetch(key, state, options) {\n    this.naja.makeRequest('GET', state.href, null, {\n      ...options,\n      history: false,\n      snippetCache: false\n    });\n    return null;\n  }\n}\nclass HistoryCacheStorage {\n  constructor() {\n    this.type = 'history';\n  }\n  store(data) {\n    return data;\n  }\n  fetch(key) {\n    return key;\n  }\n}\nclass SessionCacheStorage {\n  constructor() {\n    this.type = 'session';\n  }\n  store(data) {\n    const key = Math.random().toString(36).substring(2, 8);\n    window.sessionStorage.setItem(key, JSON.stringify(data));\n    return key;\n  }\n  fetch(key) {\n    const data = window.sessionStorage.getItem(key);\n    if (data === null) {\n      return null;\n    }\n    return JSON.parse(data);\n  }\n}\nclass ScriptLoader {\n  constructor(naja) {\n    this.loadedScripts = new Set();\n    naja.addEventListener('init', () => {\n      onDomReady(() => {\n        document.querySelectorAll('script[data-naja-script-id]').forEach(script => {\n          const scriptId = script.getAttribute('data-naja-script-id');\n          if (scriptId !== null && scriptId !== '') {\n            this.loadedScripts.add(scriptId);\n          }\n        });\n      });\n      naja.addEventListener('success', event => {\n        const {\n          payload\n        } = event.detail;\n        if (payload.snippets) {\n          this.loadScripts(payload.snippets);\n        }\n      });\n    });\n  }\n  loadScripts(snippets) {\n    Object.keys(snippets).forEach(id => {\n      const content = snippets[id];\n      if (!/<script/i.test(content)) {\n        return;\n      }\n      const el = window.document.createElement('div');\n      el.innerHTML = content;\n      const scripts = el.querySelectorAll('script');\n      for (let i = 0; i < scripts.length; i++) {\n        const script = scripts.item(i);\n        const scriptId = script.getAttribute('data-naja-script-id');\n        if (scriptId !== null && scriptId !== '' && this.loadedScripts.has(scriptId)) {\n          continue;\n        }\n        const scriptEl = window.document.createElement('script');\n        scriptEl.innerHTML = script.innerHTML;\n        if (script.hasAttributes()) {\n          const attrs = script.attributes;\n          for (let j = 0; j < attrs.length; j++) {\n            const attrName = attrs[j].name;\n            scriptEl.setAttribute(attrName, attrs[j].value);\n          }\n        }\n        window.document.head.appendChild(scriptEl).parentNode.removeChild(scriptEl);\n        if (scriptId !== null && scriptId !== '') {\n          this.loadedScripts.add(scriptId);\n        }\n      }\n    });\n  }\n}\nclass Naja extends EventTarget {\n  constructor(uiHandler, redirectHandler, snippetHandler, formsHandler, historyHandler, snippetCache, scriptLoader) {\n    super();\n    this.VERSION = 2;\n    this.initialized = false;\n    this.extensions = [];\n    this.defaultOptions = {};\n    this.uiHandler = new (uiHandler ?? UIHandler)(this);\n    this.redirectHandler = new (redirectHandler ?? RedirectHandler)(this);\n    this.snippetHandler = new (snippetHandler ?? SnippetHandler)(this);\n    this.formsHandler = new (formsHandler ?? FormsHandler)(this);\n    this.historyHandler = new (historyHandler ?? HistoryHandler)(this);\n    this.snippetCache = new (snippetCache ?? SnippetCache)(this);\n    this.scriptLoader = new (scriptLoader ?? ScriptLoader)(this);\n  }\n  registerExtension(extension) {\n    if (this.initialized) {\n      extension.initialize(this);\n    }\n    this.extensions.push(extension);\n  }\n  initialize(defaultOptions = {}) {\n    if (this.initialized) {\n      throw new Error('Cannot initialize Naja, it is already initialized.');\n    }\n    this.defaultOptions = this.prepareOptions(defaultOptions);\n    this.extensions.forEach(extension => extension.initialize(this));\n    this.dispatchEvent(new CustomEvent('init', {\n      detail: {\n        defaultOptions: this.defaultOptions\n      }\n    }));\n    this.initialized = true;\n  }\n  prepareOptions(options) {\n    return {\n      ...this.defaultOptions,\n      ...options,\n      fetch: {\n        ...this.defaultOptions.fetch,\n        ...options?.fetch\n      }\n    };\n  }\n  async makeRequest(method, url, data = null, options = {}) {\n    // normalize url to instanceof URL\n    if (typeof url === 'string') {\n      url = new URL(url, location.href);\n    }\n    options = this.prepareOptions(options);\n    const headers = new Headers(options.fetch.headers || {});\n    const body = this.transformData(url, method, data);\n    const abortController = new AbortController();\n    const request = new Request(url.toString(), {\n      credentials: 'same-origin',\n      ...options.fetch,\n      method,\n      headers,\n      body,\n      signal: abortController.signal\n    });\n    // impersonate XHR so that Nette can detect isAjax()\n    request.headers.set('X-Requested-With', 'XMLHttpRequest');\n    // hint the server that Naja expects response to be JSON\n    request.headers.set('Accept', 'application/json');\n    if (!this.dispatchEvent(new CustomEvent('before', {\n      cancelable: true,\n      detail: {\n        request,\n        method,\n        url: url.toString(),\n        data,\n        options\n      }\n    }))) {\n      return {};\n    }\n    const promise = window.fetch(request);\n    this.dispatchEvent(new CustomEvent('start', {\n      detail: {\n        request,\n        promise,\n        abortController,\n        options\n      }\n    }));\n    let response, payload;\n    try {\n      response = await promise;\n      if (!response.ok) {\n        throw new HttpError(response);\n      }\n      payload = await response.json();\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        this.dispatchEvent(new CustomEvent('abort', {\n          detail: {\n            request,\n            error,\n            options\n          }\n        }));\n        this.dispatchEvent(new CustomEvent('complete', {\n          detail: {\n            request,\n            response,\n            payload: undefined,\n            error,\n            options\n          }\n        }));\n        return {};\n      }\n      this.dispatchEvent(new CustomEvent('error', {\n        detail: {\n          request,\n          response,\n          error,\n          options\n        }\n      }));\n      this.dispatchEvent(new CustomEvent('complete', {\n        detail: {\n          request,\n          response,\n          payload: undefined,\n          error,\n          options\n        }\n      }));\n      throw error;\n    }\n    this.dispatchEvent(new CustomEvent('payload', {\n      detail: {\n        request,\n        response,\n        payload,\n        options\n      }\n    }));\n    this.dispatchEvent(new CustomEvent('success', {\n      detail: {\n        request,\n        response,\n        payload,\n        options\n      }\n    }));\n    this.dispatchEvent(new CustomEvent('complete', {\n      detail: {\n        request,\n        response,\n        payload,\n        error: undefined,\n        options\n      }\n    }));\n    return payload;\n  }\n  appendToQueryString(searchParams, key, value) {\n    if (value === null || value === undefined) {\n      return;\n    }\n    if (Array.isArray(value) || Object.getPrototypeOf(value) === Object.prototype) {\n      for (const [subkey, subvalue] of Object.entries(value)) {\n        this.appendToQueryString(searchParams, `${key}[${subkey}]`, subvalue);\n      }\n    } else {\n      searchParams.append(key, String(value));\n    }\n  }\n  transformData(url, method, data) {\n    const isGet = ['GET', 'HEAD'].includes(method.toUpperCase());\n    // sending a form via GET -> serialize FormData into URL and return empty request body\n    if (isGet && data instanceof FormData) {\n      for (const [key, value] of data) {\n        if (value !== null && value !== undefined) {\n          url.searchParams.append(key, String(value));\n        }\n      }\n      return null;\n    }\n    // sending a POJO -> serialize it recursively into URLSearchParams\n    const isDataPojo = data !== null && Object.getPrototypeOf(data) === Object.prototype;\n    if (isDataPojo || Array.isArray(data)) {\n      // for GET requests, append values to URL and return empty request body\n      // otherwise build `new URLSearchParams()` to act as the request body\n      const transformedData = isGet ? url.searchParams : new URLSearchParams();\n      for (const [key, value] of Object.entries(data)) {\n        this.appendToQueryString(transformedData, key, value);\n      }\n      return isGet ? null : transformedData;\n    }\n    return data;\n  }\n}\nclass HttpError extends Error {\n  constructor(response) {\n    const message = `HTTP ${response.status}: ${response.statusText}`;\n    super(message);\n    this.name = this.constructor.name;\n    this.stack = new Error(message).stack;\n    this.response = response;\n  }\n}\nclass AbortExtension {\n  constructor() {\n    this.abortControllers = new Set();\n  }\n  initialize(naja) {\n    naja.uiHandler.addEventListener('interaction', this.checkAbortable.bind(this));\n    naja.addEventListener('init', this.onInitialize.bind(this));\n    naja.addEventListener('start', this.saveAbortController.bind(this));\n    naja.addEventListener('complete', this.removeAbortController.bind(this));\n  }\n  onInitialize() {\n    document.addEventListener('keydown', event => {\n      if (event.key === 'Escape' && !(event.ctrlKey || event.shiftKey || event.altKey || event.metaKey)) {\n        for (const controller of this.abortControllers) {\n          controller.abort();\n        }\n        this.abortControllers.clear();\n      }\n    });\n  }\n  checkAbortable(event) {\n    const {\n      element,\n      options\n    } = event.detail;\n    if (element.hasAttribute('data-naja-abort') || element.form?.hasAttribute('data-naja-abort')) {\n      options.abort = (element.getAttribute('data-naja-abort') ?? element.form?.getAttribute('data-naja-abort')) !== 'off';\n    }\n  }\n  saveAbortController(event) {\n    const {\n      abortController,\n      options\n    } = event.detail;\n    if (options.abort !== false) {\n      this.abortControllers.add(abortController);\n      options.clearAbortExtension = () => this.abortControllers.delete(abortController);\n    }\n  }\n  removeAbortController(event) {\n    const {\n      options\n    } = event.detail;\n    if (options.abort !== false && !!options.clearAbortExtension) {\n      options.clearAbortExtension();\n    }\n  }\n}\nclass UniqueExtension {\n  constructor() {\n    this.abortControllers = new Map();\n  }\n  initialize(naja) {\n    naja.uiHandler.addEventListener('interaction', this.checkUniqueness.bind(this));\n    naja.addEventListener('start', this.abortPreviousRequest.bind(this));\n    naja.addEventListener('complete', this.clearRequest.bind(this));\n  }\n  checkUniqueness(event) {\n    const {\n      element,\n      options\n    } = event.detail;\n    const unique = element.getAttribute('data-naja-unique') ?? element.form?.getAttribute('data-naja-unique');\n    options.unique = unique === 'off' ? false : unique ?? 'default';\n  }\n  abortPreviousRequest(event) {\n    const {\n      abortController,\n      options\n    } = event.detail;\n    if (options.unique !== false) {\n      this.abortControllers.get(options.unique ?? 'default')?.abort();\n      this.abortControllers.set(options.unique ?? 'default', abortController);\n    }\n  }\n  clearRequest(event) {\n    const {\n      request,\n      options\n    } = event.detail;\n    if (!request.signal.aborted && options.unique !== false) {\n      this.abortControllers.delete(options.unique ?? 'default');\n    }\n  }\n}\nconst naja = new Naja();\nnaja.registerExtension(new AbortExtension());\nnaja.registerExtension(new UniqueExtension());\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/naja/dist/Naja.esm.js?");

/***/ }),

/***/ "./www/scripts/index.js":
/*!******************************!*\
  !*** ./www/scripts/index.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var naja__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! naja */ \"./node_modules/naja/dist/Naja.esm.js\");\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  naja__WEBPACK_IMPORTED_MODULE_0__[\"default\"].initialize();\n});\n\n//# sourceURL=webpack://my-webpack-project/./www/scripts/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./www/scripts/index.js");
/******/ 	
/******/ })()
;